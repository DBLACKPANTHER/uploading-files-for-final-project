from flask import Flask, request, jsonify
from flask_cors import CORS
import tensorflow as tf
import numpy as np
import base64
import cv2
from io import BytesIO
from PIL import Image
import os
import traceback
import gdown
from retinaface import RetinaFace

# === Model Setup ===
FILE_ID = "1dq37olSJDnUzIEPOuWjLuW0Sb"
MODEL_FILENAME = "age_model_vgg16.keras"
MODEL_PATH = os.path.join(os.path.abspath(os.path.dirname(__file__)), MODEL_FILENAME)

# === Download model from Google Drive if not present ===
if not os.path.exists(MODEL_PATH):
    print("‚¨áÔ∏è Downloading model from Google Drive...")
    gdown.download(id=FILE_ID, output=MODEL_PATH, quiet=False)
else:
    print(f"‚úÖ Model already exists at: {MODEL_PATH}")

print("‚úÖ Loading model...")
model = tf.keras.models.load_model(MODEL_PATH)
print(f"‚úÖ Model loaded from: {MODEL_PATH}")

IMG_SIZE = (224, 224)

AGE_GROUPS = {
    0: "0‚Äì18",
    1: "19‚Äì40",
    2: "41‚Äì60",
    3: "61‚Äì80",
    4: "81+"
}

# === Flask App ===
app = Flask(__name__)
CORS(app)

# === Load Haar Cascade ===
CASCADE_PATH = cv2.data.haarcascades + "haarcascade_frontalface_default.xml"
face_cascade = cv2.CascadeClassifier(CASCADE_PATH)

@app.route('/predict', methods=['POST'])
def predict():
    try:
        data = request.get_json()
        if 'image' not in data:
            return jsonify({'error': 'No image provided'}), 400

        image_data = data['image']
        if ',' in image_data:
            image_data = image_data.split(',')[1]

        decoded = base64.b64decode(image_data)
        img = Image.open(BytesIO(decoded)).convert('RGB')
        img_np = np.array(img)
        original_img = img_np.copy()
        results = []

        gray = cv2.cvtColor(img_np, cv2.COLOR_RGB2GRAY)
        faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)

        if len(faces) == 0:
            return jsonify({"faces": [], "blurred_image": data['image']}), 200

        for (x, y, w, h) in faces:
            x1, y1, x2, y2 = x, y, x + w, y + h
            face_crop = img_np[y1:y2, x1:x2]

            if face_crop.size == 0:
                continue

            try:
                resized = cv2.resize(face_crop, IMG_SIZE)
            except Exception as e:
                print(f"‚ö† Resize failed: {e}")
                continue

            input_tensor = np.expand_dims(resized / 255.0, axis=0)
            pred = model.predict(input_tensor, verbose=0)
            pred_class = int(np.argmax(pred))
            predicted_age_group = AGE_GROUPS.get(pred_class, "Unknown")

            if predicted_age_group == "0‚Äì18":
                try:
                    blurred = cv2.GaussianBlur(face_crop, (99, 99), 30)
                    original_img[y1:y2, x1:x2] = blurred
                except Exception as e:
                    print(f"‚ö† Blurring failed: {e}")

            results.append({"predicted_age_group": predicted_age_group})

        try:
            _, buffer = cv2.imencode('.jpg', cv2.cvtColor(original_img, cv2.COLOR_RGB2BGR))
            img_base64 = base64.b64encode(buffer).decode('utf-8')
            image_uri = f"data:image/jpeg;base64,{img_base64}"
        except Exception as encoding_error:
            print(f"‚ùå Encoding error: {encoding_error}")
            image_uri = data['image']

        return jsonify({
            "faces": results,
            "blurred_image": image_uri
        })

    except Exception as e:
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    print("üöÄ Starting Flask server...")
    app.run(debug=True, use_reloader=False)
